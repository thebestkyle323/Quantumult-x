/******************************************
 * @name 最新技術推送
 * @statement 仅供学习交流|禁止用于商业用途|转载请注明来源
 * tg频道： https://t.me/Ifantasticsgame
 * @version 1.0.0
 * @update 20230630
 * @description CAOLIU技術討論區最新技術推送
******************************************
Quantumult X:
[task_local]
0 8,14,20 * * * https://raw.githubusercontent.com/thebestkyle323/Quantumult-x/main/1024.js, tag=最新技術推送

******************************************/
let scriptName = '草榴技術討論區'
    , $ = new Env(scriptName)
    , request = $.http
    , baseURL = 'https://t66y.com/'
    , $posts = []
    , $postContent = void 0
!(async () =&gt; {
    // 获取今日帖子
    await getPosts()
    // 获取随机帖子内容
    const random = (min, max) =&gt; Math.floor(Math.random() * (max - min + 1) + min);
    const randomIdx = random(0, $posts.length - 1);
    let postsContent = $posts[randomIdx];
    // 获取最新帖子(u can choose...)
    postsContent = $posts[0];
    await getPostContent(postsContent)
    $.notify(
        `🔔${scriptName}`,
        `《${postsContent.title}》\n【发布时间】\n${$.time('yyyy-MM-dd HH:mm:ss', postsContent.date)}`,
        $postContent,
        { 'open-url': postsContent.href }
    )
})()
    .catch((e) =&gt; {
        $.log('', `❌ ${$.name}, 失败! 原因: ${e}!`, '')
    })
    .finally(() =&gt; {
        $.done()
    });
function getPosts() {
    const url = baseURL + 'thread0806.php?fid=7&amp;search=today'
    return new Promise(async (resolve, reject) =&gt; {
        const { body: html } = await request.get(url);
        try {
            $posts = html
                .replace(/\n|\s|\r/g, '')
                .match(/&lt;tbody.*?id=\"tbody\"&gt;(.*?)&lt;\/tbody&gt;/g)[0]
                .match(/&lt;tbodystyle=\"table-layout:fixed;\"id=\"tbody\"&gt;(.*?)&lt;\/tbody&gt;/)[1]
                .match(/&lt;trclass=\"tr3t_onetac"\&gt;(.*?)&lt;\/tr&gt;/g)
                .map(item =&gt; {
                    let [, href, title, date] = item.match(/&lt;h3&gt;&lt;ahref=\"(.*?)\".*?&gt;(.*?)&lt;\/a&gt;&lt;\/h3&gt;.*?data-timestamp=\"(.*?)\"/);
                    date = Number(date.slice(-1)) ? date : date.slice(0, -1)
                    return { href: baseURL + href, title, date: date * 1e3 }
                })
                .filter(item =&gt; !/\[\d+P\]/.test(item.title))
            resolve()
        } catch (e) {
            reject(e || '获取帖子失败')
        }
    })
}
function getPostContent(obj) {
    let { href, title, date } = obj;
    $.log('', ` 《${title}》`, '【发布时间】', $.time('yyyy-MM-dd HH:mm:ss', date), '')
    return new Promise(async (resolve, reject) =&gt; {
        const { body: html } = await request.get(href);
        try {
            $postContent = html.replace(/\n|\s|\r/g, '')
                .match(/&lt;tdbgcolor.*?valign=\"top\"&gt;(.*?)&lt;\/td&gt;/)[0]
                .match(/&lt;div.*?id=\"conttpc\"&gt;(.*?)&lt;\/div&gt;/)[1]
                .replace(/&lt;br&gt;&lt;br&gt;/g, '\n').replace(/&lt;br&gt;/g, '\n')
                .replace(/&amp;nbsp;/g, '').replace(/&amp;amp;/g, '&amp;').replace(/&amp;quot;/g, '"').replace(/&amp;lt;/g, '&lt;').replace(/&amp;gt;/g, '&gt;')
                .replace(/&lt;.*?&gt;/g, '')
            resolve()
        } catch (e) {
            reject(e || '获取帖子内容失败')
        }
    })
}
// prettier-ignore
function Env(name, opts) { class Http { constructor(env) { this.env = env } send(opts, method = "GET") { opts = "string" == typeof opts ? { url: opts } : opts; let sender = this.get; return "POST" === method &amp;&amp; (sender = this.post), new Promise((resolve, reject) =&gt; { sender.call(this, opts, (err, resp, body) =&gt; { err ? reject(err) : resolve(resp) }) }) } get(opts) { return this.send.call(this.env, opts) } post(opts) { return this.send.call(this.env, opts, "POST") } } return new class { constructor(name, opts) { this.name = name, this.http = new Http(this), this.data = null, this.dataFile = "box.dat", this.logs = [], this.isMute = !1, this.isNeedRewrite = !1, this.logSeparator = "\n", this.encoding = "utf-8", this.startTime = (new Date).getTime(), Object.assign(this, opts), this.log("", `🔔${this.name}, 开始!`) } getEnv() { return "undefined" != typeof $environment &amp;&amp; $environment["surge-version"] ? "Surge" : "undefined" != typeof $environment &amp;&amp; $environment["stash-version"] ? "Stash" : "undefined" != typeof module &amp;&amp; module.exports ? "Node.js" : "undefined" != typeof $task ? "Quantumult X" : "undefined" != typeof $loon ? "Loon" : "undefined" != typeof $rocket ? "Shadowrocket" : "undefined" != typeof importModule ? "Scriptable" : "function" == typeof require &amp;&amp; "undefined" != typeof $jsbox ? "JSBox" : void 0 } isNode() { return "Node.js" === this.getEnv() } isQuanX() { return "Quantumult X" === this.getEnv() } isSurge() { return "Surge" === this.getEnv() } isLoon() { return "Loon" === this.getEnv() } isShadowrocket() { return "Shadowrocket" === this.getEnv() } isStash() { return "Stash" === this.getEnv() } isScriptable() { return "Scriptable" === this.getEnv() } isJSBox() { return "JSBox" === this.getEnv() } toObj(str, defaultValue = null) { try { return JSON.parse(str) } catch { return defaultValue } } toStr(obj, defaultValue = null) { try { return JSON.stringify(obj) } catch { return defaultValue } } getjson(key, defaultValue) { let json = defaultValue; const val = this.getdata(key); if (val) try { json = JSON.parse(this.getdata(key)) } catch { } return json } setjson(val, key) { try { return this.setdata(JSON.stringify(val), key) } catch { return !1 } } getScript(url) { return new Promise(resolve =&gt; { this.get({ url: url }, (err, resp, body) =&gt; resolve(body)) }) } runScript(script, runOpts) { return new Promise(resolve =&gt; { let httpapi = this.getdata("@chavy_boxjs_userCfgs.httpapi"); httpapi = httpapi ? httpapi.replace(/\n/g, "").trim() : httpapi; let httpapi_timeout = this.getdata("@chavy_boxjs_userCfgs.httpapi_timeout"); httpapi_timeout = httpapi_timeout ? 1 * httpapi_timeout : 20, httpapi_timeout = runOpts &amp;&amp; runOpts.timeout ? runOpts.timeout : httpapi_timeout; const [key, addr] = httpapi.split("@"), opts = { url: `http://${addr}/v1/scripting/evaluate`, body: { script_text: script, mock_type: "cron", timeout: httpapi_timeout }, headers: { "X-Key": key, Accept: "*/*" }, timeout: httpapi_timeout }; this.post(opts, (err, resp, body) =&gt; resolve(body)) }).catch(e =&gt; this.logErr(e)) } loaddata() { if (!this.isNode()) return {}; { this.fs = this.fs ? this.fs : require("fs"), this.path = this.path ? this.path : require("path"); const curDirDataFilePath = this.path.resolve(this.dataFile), rootDirDataFilePath = this.path.resolve(process.cwd(), this.dataFile), isCurDirDataFile = this.fs.existsSync(curDirDataFilePath), isRootDirDataFile = !isCurDirDataFile &amp;&amp; this.fs.existsSync(rootDirDataFilePath); if (!isCurDirDataFile &amp;&amp; !isRootDirDataFile) return {}; { const datPath = isCurDirDataFile ? curDirDataFilePath : rootDirDataFilePath; try { return JSON.parse(this.fs.readFileSync(datPath)) } catch (e) { return {} } } } } writedata() { if (this.isNode()) { this.fs = this.fs ? this.fs : require("fs"), this.path = this.path ? this.path : require("path"); const curDirDataFilePath = this.path.resolve(this.dataFile), rootDirDataFilePath = this.path.resolve(process.cwd(), this.dataFile), isCurDirDataFile = this.fs.existsSync(curDirDataFilePath), isRootDirDataFile = !isCurDirDataFile &amp;&amp; this.fs.existsSync(rootDirDataFilePath), jsondata = JSON.stringify(this.data); isCurDirDataFile ? this.fs.writeFileSync(curDirDataFilePath, jsondata) : isRootDirDataFile ? this.fs.writeFileSync(rootDirDataFilePath, jsondata) : this.fs.writeFileSync(curDirDataFilePath, jsondata) } } lodash_get(source, path, defaultValue) { const paths = path.replace(/\[(\d+)\]/g, ".$1").split("."); let result = source; for (const p of paths) if (result = Object(result)[p], void 0 === result) return defaultValue; return result } lodash_set(obj, path, value) { return Object(obj) !== obj ? obj : (Array.isArray(path) || (path = path.toString().match(/[^.[\]]+/g) || []), path.slice(0, -1).reduce((a, c, i) =&gt; Object(a[c]) === a[c] ? a[c] : a[c] = Math.abs(path[i + 1]) &gt;&gt; 0 == +path[i + 1] ? [] : {}, obj)[path[path.length - 1]] = value, obj) } getdata(key) { let val = this.getval(key); if (/^@/.test(key)) { const [, objkey, paths] = /^@(.*?)\.(.*?)$/.exec(key), objval = objkey ? this.getval(objkey) : ""; if (objval) try { const objedval = JSON.parse(objval); val = objedval ? this.lodash_get(objedval, paths, "") : val } catch (e) { val = "" } } return val } setdata(val, key) { let issuc = !1; if (/^@/.test(key)) { const [, objkey, paths] = /^@(.*?)\.(.*?)$/.exec(key), objdat = this.getval(objkey), objval = objkey ? "null" === objdat ? null : objdat || "{}" : "{}"; try { const objedval = JSON.parse(objval); this.lodash_set(objedval, paths, val), issuc = this.setval(JSON.stringify(objedval), objkey) } catch (e) { const objedval = {}; this.lodash_set(objedval, paths, val), issuc = this.setval(JSON.stringify(objedval), objkey) } } else issuc = this.setval(val, key); return issuc } getval(key) { switch (this.getEnv()) { case "Surge": case "Loon": case "Stash": case "Shadowrocket": return $persistentStore.read(key); case "Quantumult X": return $prefs.valueForKey(key); case "Node.js": return this.data = this.loaddata(), this.data[key]; default: return this.data &amp;&amp; this.data[key] || null } } setval(val, key) { switch (this.getEnv()) { case "Surge": case "Loon": case "Stash": case "Shadowrocket": return $persistentStore.write(val, key); case "Quantumult X": return $prefs.setValueForKey(val, key); case "Node.js": return this.data = this.loaddata(), this.data[key] = val, this.writedata(), !0; default: return this.data &amp;&amp; this.data[key] || null } } initGotEnv(opts) { this.got = this.got ? this.got : require("got"), this.cktough = this.cktough ? this.cktough : require("tough-cookie"), this.ckjar = this.ckjar ? this.ckjar : new this.cktough.CookieJar, opts &amp;&amp; (opts.headers = opts.headers ? opts.headers : {}, void 0 === opts.headers.Cookie &amp;&amp; void 0 === opts.cookieJar &amp;&amp; (opts.cookieJar = this.ckjar)) } get(request, callback = (() =&gt; { })) { switch (request.headers &amp;&amp; (delete request.headers["Content-Type"], delete request.headers["Content-Length"], delete request.headers["content-type"], delete request.headers["content-length"]), this.getEnv()) { case "Surge": case "Loon": case "Stash": case "Shadowrocket": default: this.isSurge() &amp;&amp; this.isNeedRewrite &amp;&amp; (request.headers = request.headers || {}, Object.assign(request.headers, { "X-Surge-Skip-Scripting": !1 })), $httpClient.get(request, (err, resp, body) =&gt; { !err &amp;&amp; resp &amp;&amp; (resp.body = body, resp.statusCode = resp.status ? resp.status : resp.statusCode, resp.status = resp.statusCode), callback(err, resp, body) }); break; case "Quantumult X": this.isNeedRewrite &amp;&amp; (request.opts = request.opts || {}, Object.assign(request.opts, { hints: !1 })), $task.fetch(request).then(resp =&gt; { const { statusCode: status, statusCode: statusCode, headers: headers, body: body, bodyBytes: bodyBytes } = resp; callback(null, { status: status, statusCode: statusCode, headers: headers, body: body, bodyBytes: bodyBytes }, body, bodyBytes) }, err =&gt; callback(err &amp;&amp; err.error || "UndefinedError")); break; case "Node.js": let iconv = require("iconv-lite"); this.initGotEnv(request), this.got(request).on("redirect", (resp, nextOpts) =&gt; { try { if (resp.headers["set-cookie"]) { const ck = resp.headers["set-cookie"].map(this.cktough.Cookie.parse).toString(); ck &amp;&amp; this.ckjar.setCookieSync(ck, null), nextOpts.cookieJar = this.ckjar } } catch (e) { this.logErr(e) } }).then(resp =&gt; { const { statusCode: status, statusCode: statusCode, headers: headers, rawBody: rawBody } = resp, body = iconv.decode(rawBody, this.encoding); callback(null, { status: status, statusCode: statusCode, headers: headers, rawBody: rawBody, body: body }, body) }, err =&gt; { const { message: error, response: resp } = err; callback(error, resp, resp &amp;&amp; iconv.decode(resp.rawBody, this.encoding)) }) } } post(request, callback = (() =&gt; { })) { const method = request.method ? request.method.toLocaleLowerCase() : "post"; switch (request.body &amp;&amp; request.headers &amp;&amp; !request.headers["Content-Type"] &amp;&amp; !request.headers["content-type"] &amp;&amp; (request.headers["content-type"] = "application/x-www-form-urlencoded"), request.headers &amp;&amp; (delete request.headers["Content-Length"], delete request.headers["content-length"]), this.getEnv()) { case "Surge": case "Loon": case "Stash": case "Shadowrocket": default: this.isSurge() &amp;&amp; this.isNeedRewrite &amp;&amp; (request.headers = request.headers || {}, Object.assign(request.headers, { "X-Surge-Skip-Scripting": !1 })), $httpClient[method](request, (err, resp, body) =&gt; { !err &amp;&amp; resp &amp;&amp; (resp.body = body, resp.statusCode = resp.status ? resp.status : resp.statusCode, resp.status = resp.statusCode), callback(err, resp, body) }); break; case "Quantumult X": request.method = method, this.isNeedRewrite &amp;&amp; (request.opts = request.opts || {}, Object.assign(request.opts, { hints: !1 })), $task.fetch(request).then(resp =&gt; { const { statusCode: status, statusCode: statusCode, headers: headers, body: body, bodyBytes: bodyBytes } = resp; callback(null, { status: status, statusCode: statusCode, headers: headers, body: body, bodyBytes: bodyBytes }, body, bodyBytes) }, err =&gt; callback(err &amp;&amp; err.error || "UndefinedError")); break; case "Node.js": let iconv = require("iconv-lite"); this.initGotEnv(request); const { url: url, ..._request } = request; this.got[method](url, _request).then(resp =&gt; { const { statusCode: status, statusCode: statusCode, headers: headers, rawBody: rawBody } = resp, body = iconv.decode(rawBody, this.encoding); callback(null, { status: status, statusCode: statusCode, headers: headers, rawBody: rawBody, body: body }, body) }, err =&gt; { const { message: error, response: resp } = err; callback(error, resp, resp &amp;&amp; iconv.decode(resp.rawBody, this.encoding)) }) } } time(fmt, ts = null) { const date = ts ? new Date(ts) : new Date; let o = { "M+": date.getMonth() + 1, "d+": date.getDate(), "H+": date.getHours(), "m+": date.getMinutes(), "s+": date.getSeconds(), "q+": Math.floor((date.getMonth() + 3) / 3), S: date.getMilliseconds() }; /(y+)/.test(fmt) &amp;&amp; (fmt = fmt.replace(RegExp.$1, (date.getFullYear() + "").substr(4 - RegExp.$1.length))); for (let k in o) new RegExp("(" + k + ")").test(fmt) &amp;&amp; (fmt = fmt.replace(RegExp.$1, 1 == RegExp.$1.length ? o[k] : ("00" + o[k]).substr(("" + o[k]).length))); return fmt } queryStr(options) { let queryString = ""; for (const key in options) { let value = options[key]; null != value &amp;&amp; "" !== value &amp;&amp; ("object" == typeof value &amp;&amp; (value = JSON.stringify(value)), queryString += `${key}=${value}&amp;`) } return queryString = queryString.substring(0, queryString.length - 1), queryString } msg(title = name, subt = "", desc = "", opts) { const toEnvOpts = rawopts =&gt; { switch (typeof rawopts) { case void 0: return rawopts; case "string": switch (this.getEnv()) { case "Surge": case "Stash": default: return { url: rawopts }; case "Loon": case "Shadowrocket": return rawopts; case "Quantumult X": return { "open-url": rawopts }; case "Node.js": return }case "object": switch (this.getEnv()) { case "Surge": case "Stash": case "Shadowrocket": default: { let openUrl; return { url: rawopts.url || rawopts.openUrl || rawopts["open-url"] } } case "Loon": { let openUrl, mediaUrl; return { openUrl: rawopts.openUrl || rawopts.url || rawopts["open-url"], mediaUrl: rawopts.mediaUrl || rawopts["media-url"] } } case "Quantumult X": { let openUrl, mediaUrl, updatePasteboard; return { "open-url": rawopts["open-url"] || rawopts.url || rawopts.openUrl, "media-url": rawopts["media-url"] || rawopts.mediaUrl, "update-pasteboard": rawopts["update-pasteboard"] || rawopts.updatePasteboard } } case "Node.js": return }default: return } }; if (!this.isMute) switch (this.getEnv()) { case "Surge": case "Loon": case "Stash": case "Shadowrocket": default: $notification.post(title, subt, desc, toEnvOpts(opts)); break; case "Quantumult X": $notify(title, subt, desc, toEnvOpts(opts)); break; case "Node.js": }if (!this.isMuteLog) { let logs = ["", "==============📣系统通知📣=============="]; logs.push(title), subt &amp;&amp; logs.push(subt), desc &amp;&amp; logs.push(desc), console.log(logs.join("\n")), this.logs = this.logs.concat(logs) } } notify(title = name, subtitle = "", content = "", options = {}) { const openURL = options["open-url"], mediaURL = options["media-url"]; if (this.isQuanX() &amp;&amp; $notify(title, subtitle, content, options), this.isSurge() &amp;&amp; $notification.post(title, subtitle, content + `${mediaURL ? "\n多媒体:" + mediaURL : ""}`, { url: openURL }), this.isLoon()) { let opts = {}; openURL &amp;&amp; (opts.openUrl = openURL), mediaURL &amp;&amp; (opts.mediaUrl = mediaURL), "{}" === JSON.stringify(opts) ? $notification.post(title, subtitle, content) : $notification.post(title, subtitle, content, opts) } if (this.isJSBox()) { const content_ = content + (openURL ? `\n点击跳转: ${openURL}` : "") + (mediaURL ? `\n多媒体: ${mediaURL}` : ""), push = require("push"); push.schedule({ title: title, body: (subtitle ? subtitle + "\n" : "") + content_ }) } if (!this.isMuteLog) { let logs = ["", "==============📣系统通知📣=============="]; logs.push(title), subtitle &amp;&amp; logs.push(subtitle), content &amp;&amp; logs.push(content + (openURL ? `\n点击跳转: ${openURL}` : "") + (mediaURL ? `\n多媒体: ${mediaURL}` : "")), console.log(logs.join("\n")), this.logs = this.logs.concat(logs) } } log(...logs) { logs.length &gt; 0 &amp;&amp; (this.logs = [...this.logs, ...logs]), console.log(logs.join(this.logSeparator)) } logErr(err, msg) { switch (this.getEnv()) { case "Surge": case "Loon": case "Stash": case "Shadowrocket": case "Quantumult X": default: this.log("", `❗️${this.name}, 错误!`, err); break; case "Node.js": this.log("", `❗️${this.name}, 错误!`, err.stack) } } wait(time) { return new Promise(resolve =&gt; setTimeout(resolve, time)) } done(val = {}) { const endTime = (new Date).getTime(), costTime = (endTime - this.startTime) / 1e3; switch (this.log("", `🔔${this.name}, 结束! 🕛 ${costTime} 秒`), this.log(), this.getEnv()) { case "Surge": case "Loon": case "Stash": case "Shadowrocket": case "Quantumult X": default: $done(val); break; case "Node.js": process.exit(1) } } }(name, opts) }
